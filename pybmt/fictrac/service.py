import subprocess
import time
import os
import zmq

from pybmt.fictrac.state import FicTracState
from pybmt.tools import which


class FicTracDriver:
    """
    This class drives the tracking of the fly via a separate software called FicTrac. 
    It invokes this process and provides functionality for reading out the track state.
    """
    def __init__(self, config_file=None, remote_endpoint_url=None, console_ouput_file="output.txt",
                 pgr_enable=False, fic_trac_bin_path=None, save_dir=None):
        """
        Create the FicTrac driver object. This function will perform a check to see if the FicTrac program is present
        on the path. If it is not, it will throw an exception.

        :param str config_file: The path to the configuration file that should be passed to the FicTrac command.
        :param str remote_endpoint_url: If FicTrac is already running on another machine, this is the url.
        :param str console_output_file: The path to the file where console output should be stored.
        :param bool pgr_enable: Is Point Grey camera support needed. This just decides which executable to call, either
        'FicTrac' or 'FicTrac-PGR'.
        :param str fic_trac_bin_path: The path the the fictrac binary to use. Default is None. If None, we will try to
        find fictrac on the path.
        :param str remote_endpoint_url
        :param str save_dir: folder to save files generated by fictrac to. 
        """

        # If fictrac is already running, for example, on another machine, then we don't need to worry about running it.
        if remote_endpoint_url is not None:
            self.remote_endpoint_url = "tcp://" + remote_endpoint_url
            self.start_fictrac = False
        else:
            self.start_fictrac = True
            self.remote_endpoint_url = "tcp://localhost:5556"
            self.config_file = config_file

            # Get the directory that the config file is in, this will be the current working directory
            # of FicTrac.
            self.config_dir = os.path.dirname(self.config_file)
            if self.config_dir == "":
                self.config_dir = None

            # Get base config file name
            self.config_file_base = os.path.basename(self.config_file)
            if save_dir is None:
                self.save_dir = self.config_dir
            else:
                self.save_dir = save_dir
                os.makedirs(self.save_dir, exist_ok=True)  # ensure save_dir exists

            self.console_output_file = console_ouput_file
            self.pgr_enable = pgr_enable

            # If the user didn't specify the path to fictrac, look for it on the path.
            if fic_trac_bin_path is None:
                self.fictrac_bin = 'fictrac'
                if self.pgr_enable:
                    self.fictrac_bin = 'fictrac-pgr'

                # If this is Windows, we need to add the .exe extension.
                if os.name == 'nt':
                    self.fictrac_bin = self.fictrac_bin + ".exe"

                # Lets make sure FicTrac exists on the path
                self.fictrac_bin_fullpath = which(self.fictrac_bin)

                if self.fictrac_bin_fullpath is None:
                    raise RuntimeError("Could not find " + self.fictrac_bin + " on the PATH!")

            else:
                self.fictrac_bin_fullpath = fic_trac_bin_path

        self.fictrac_process = None

    @classmethod
    def as_server(cls, config_file, savefilename):
        fictrac_console_out = savefilename + "_out.txt"
        fictrac_savedir = os.path.dirname(savefilename)
        server = cls(config_file=config_file, console_ouput_file=fictrac_console_out,
                     pgr_enable=True, save_dir=fictrac_savedir)
        server._start_fictrac()
        return server

    @classmethod
    def as_client(cls, remote_endpoint_url):
        client = cls(remote_endpoint_url=remote_endpoint_url)
        client._setup_comms()
        return client

    def _start_fictrac(self):
        """
        Start the the FicTrac process and block till it closes. This function will poll a shared memory region for
        changes in tracking data and invoke a control function when they occur. FicTrac is assumed to exist on the
        system path.

        :return:
        """
        with open(self.console_output_file, "wb") as out:
            self.fictrac_process = subprocess.Popen([self.fictrac_bin_fullpath,
                                                    self.config_file],
                                                    stdout=out, stderr=subprocess.STDOUT,
                                                    cwd=self.save_dir)

    def _setup_comms(self):

        #  Setup ZeroMQ context and socket to talk to server
        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.SUB)

        # Set a timeout on this socket so we don't block forever
        self.socket.RCVTIMEO = 1  # in milliseconds

        # This is the receiver high water mark, zero mq will start to drop incoming messages after it
        # has queued this many. This will let us detect if we are not picking up messages quick enough because of a
        # slow callback process. This isn't perfect though since OS buffers messages as well.
        self.socket.setsockopt(zmq.RCVHWM, 1)

        # Bind and subscribe
        self.socket.connect(self.remote_endpoint_url)
        self.socket.setsockopt(zmq.SUBSCRIBE, b"")

        self.poller = zmq.Poller()
        self.poller.register(self.socket, zmq.POLLIN)

    def _read_message(self):
        data = None
        try:
            evts = self.poller.poll(.001)
            if evts:
                data = self.socket.recv_string()
                if data != "END":
                    try:
                    # Parse the data packet into our state structure. Get our new state.
                        data = FicTracState.zmq_string_msg_to_state(data)
                    except ValueError:
                        pass
        except zmq.error.Again:
            pass

        return data

    def _cleanup(self):
        """
        This is method is called whenever PyBMT run is shutting down things.

        :return:
        """
        self.fictrac_process.terminate()
